<#
.SYNOPSIS
    This PowerShell script ensures enforcement of password history = 24 passwords remembered.

.NOTES
    Author          : Javon McCloud
    LinkedIn        : linkedin.com/in/javonmccloud/
    GitHub          : github.com/mc-cloud-code-cyber
    Date Created    : 2025-09-20
    Last Modified   : 2025-09-20
    Version         : 1.0
    CVEs            : N/A
    Plugin IDs      : N/A
    STIG-ID         : WN10-AC-000020

.TESTED ON
    Date(s) Tested  : 
    Tested By       : 
    Systems Tested  : 
    PowerShell Ver. : 

.USAGE
    Put any usage instructions here.
    Example syntax:
    PS C:\> .\__remediation_template(STIG-ID-WN10-AU-000500).ps1 
#>

#Requires -RunAsAdministrator
<#
Remediates WN10-AC-000020 (Password history >= 24)
- Local: uses net accounts; verifies via secedit (reliable) then falls back to net accounts text.
- Domain: updates Default Domain Password Policy; optional -UpdatePSOs raises any PSO below the target.
- Outputs a one-line compliance object.
#>

[CmdletBinding(SupportsShouldProcess=$true)]
param(
  [ValidateRange(1,24)][int]$Count = 24,
  [switch]$Domain,          # operate on AD (requires RSAT + rights)
  [switch]$UpdatePSOs,      # also raise any PSO (< Count)
  [string]$User = $env:USERNAME  # for resultant check in domain mode
)

function Get-LocalHistoryViaSecedit {
  $tmp = Join-Path $env:TEMP "secpol_$([guid]::NewGuid().Guid).inf"
  secedit /export /cfg $tmp | Out-Null
  try {
    $m = Select-String -Path $tmp -Pattern '^\s*PasswordHistorySize\s*=\s*(\d+)' |
         Select-Object -First 1
    if ($m) { return [int]$m.Matches[0].Groups[1].Value }
    return $null
  } finally { Remove-Item $tmp -Force -ErrorAction SilentlyContinue }
}

function Get-LocalHistoryViaNet {
  $out = (net accounts) -join "`n"
  if ($out -imatch 'password\s*history.*?(\d+)') { return [int]$Matches[1] }
  if ($out -imatch 'length\s+of\s+password\s+history\s+maintained.*?(\d+)') { return [int]$Matches[1] }
  return $null
}

function Get-LocalHistory {
  $v = Get-LocalHistoryViaSecedit
  if ($null -ne $v) { return $v }
  return Get-LocalHistoryViaNet
}

function Set-Local {
  if ($PSCmdlet.ShouldProcess("Local machine","net accounts /uniquepw:$Count")) {
    cmd /c "net accounts /uniquepw:$Count" | Out-Null
  }
}

function Ensure-AD {
  if (-not (Get-Module -ListAvailable ActiveDirectory)) {
    throw "ActiveDirectory module not found. Install RSAT or run on a DC."
  }
  Import-Module ActiveDirectory -ErrorAction Stop | Out-Null
}

function Get-DomainDefault { (Get-ADDefaultDomainPasswordPolicy).PasswordHistoryCount }

function Set-DomainDefault {
  if ($PSCmdlet.ShouldProcess("Default Domain Policy","PasswordHistoryCount -> $Count")) {
    Set-ADDefaultDomainPasswordPolicy -PasswordHistoryCount $Count
  }
}

function Get-ResultantForUser($u) {
  $rp = Get-ADUserResultantPasswordPolicy -Identity $u -ErrorAction SilentlyContinue
  if ($rp) { return $rp.PasswordHistoryCount } else { return Get-DomainDefault }
}

function Update-PSOsIfRequested {
  if (-not $UpdatePSOs) { return }
  $psos = Get-ADFineGrainedPasswordPolicy -Filter *
  foreach ($p in $psos | Where-Object { $_.PasswordHistoryCount -lt $Count }) {
    if ($PSCmdlet.ShouldProcess("PSO '$($p.Name)'","Raise PasswordHistoryCount to $Count")) {
      Set-ADFineGrainedPasswordPolicy -Identity $p -PasswordHistoryCount $Count
    }
  }
}

try {
  if ($Domain) {
    Ensure-AD
    $before = Get-DomainDefault
    if ($before -lt $Count) { Set-DomainDefault }
    Update-PSOsIfRequested
    $effDefault = Get-DomainDefault
    $effUser    = Get-ResultantForUser $User
    [pscustomobject]@{
      Scope='Domain'
      Required=$Count
      DefaultPolicy=$effDefault
      ResultantForUser=$effUser
      PSOsUpdated=[bool]$UpdatePSOs
      Result= if ($effUser -ge $Count) {'Compliant'} else {'Noncompliant'}
    }
  } else {
    $before = Get-LocalHistory
    if ($before -lt $Count) { Set-Local }
    $eff = Get-LocalHistory
    [pscustomobject]@{
      Scope='Local'
      Required=$Count
      Effective=$eff
      Result= if ($eff -ge $Count) {'Compliant'} else {'Noncompliant'}
    }
  }
}
catch { Write-Error $_; exit 1 }
